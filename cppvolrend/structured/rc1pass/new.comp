#version 430

layout (binding = 1) uniform sampler3D TexVolume; 
layout (binding = 2) uniform sampler1D TexTransferFunc;
layout (binding = 3) uniform sampler3D TexVolumeGradient;
// I'm pretty sure I'm passing this right now.
// I'm using the same method as the volume texture.
layout (binding = 4) uniform sampler3D Importances;

uniform vec3 VolumeGridResolution;
uniform vec3 VolumeVoxelSize;
uniform vec3 VolumeGridSize;
uniform vec3 ImportancesGridSize; 

uniform vec3 CameraEye;

uniform mat4 u_CameraLookAt;
uniform mat4 ProjectionMatrix;

uniform float u_TanCameraFovY;
uniform float u_CameraAspectRatio;

uniform float StepSize;

uniform vec3 VolumeScales;

uniform int ApplyGradientPhongShading;

uniform float BlinnPhongKa;
uniform float BlinnPhongKd;
uniform float BlinnPhongKs;
uniform float BlinnPhongShininess;

uniform vec3 BlinnPhongIspecular;

uniform vec3 WorldEyePos;
uniform vec3 LightSourcePosition;

uniform int ApplyOcclusion;
uniform int ApplyShadow;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba16f, binding = 0) uniform image2D OutputFrag;

//////////////////////////////////////////////////////////////////////////////////////////////////
// From _structured_volume_data/ray_bbox_intersection.frag
struct Ray { vec3 Origin; vec3 Dir; };
bool RayAABBIntersection (vec3 vert_eye, vec3 vert_dir, vec3 vol_scaled_dim,
                          out Ray r, out float rtnear, out float rtfar);

// Might need a function like "NextRayIntersection" to get the next intersection point of a ray.
//   - with a step size? 
//////////////////////////////////////////////////////////////////////////////////////////////////



void main ()
{



  ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 size = imageSize(OutputFrag);
  if (storePos.x < size.x && storePos.y < size.y)
  {
    // Get screen position [x, y] and consider centering the pixel by + 0.5
    vec2 fpos = vec2(storePos) + 0.5;

    // Transform fpos from [w, h] to [0, 1] to [-1, 1]
    vec3 VerPos = (vec3(fpos.x / float(size.x), fpos.y / float(size.y), 0.0) * 2.0) - 1.0;

    // Camera direction
    vec3 camera_dir = normalize(vec3(VerPos.x * u_TanCameraFovY * u_CameraAspectRatio, VerPos.y * u_TanCameraFovY, -1.0) * mat3(u_CameraLookAt));

    // Find Ray Intersection
    Ray r; float tnear, tfar;
    bool inbox = RayAABBIntersection(CameraEye, camera_dir, VolumeGridSize, r, tnear, tfar);

    // If inside volume grid
    if(inbox)
    {
      // Distance to be evaluated
      float D = abs(tfar - tnear);

      // Initialize Transparency and Radiance color


      // World position at tnear, translated to the volume [0, VolumeGridSize]
      vec3 wld_pos = r.Origin + r.Dir * tnear;
      // Texture position
      vec3 tex_pos = wld_pos + (VolumeGridSize * 0.5);
      vec3 imp_pos = wld_pos + (ImportancesGridSize * 0.5);
      
      float min_importance = 10;


      // Evaluate from 0 to D...
      for(float s = 0.0; s < D;)
      {
        // Get the current step or the remaining interval
        float h = min(StepSize, D - s);
         h= StepSize;
      
        // Texture position at tnear + (s + h/2)
        vec3 s_tex_pos = tex_pos  + r.Dir * (s + h * 0.5);
        vec3 s_imp_pos = imp_pos  + r.Dir * (s + h * 0.5);
      
        // Get normalized density from volume
        float density = texture(TexVolume, s_tex_pos / VolumeGridSize).r;

        // Sample the importances scalar field
        float importance = texture(Importances, s_imp_pos / ImportancesGridSize ).r;
        if (importance < min_importance) min_importance = importance;

       
        // Go to the next interval
        s = s + h;
      }

      //imageStore(OutputFrag, storePos, dst);

      if (min_importance == 0.0) {
          imageStore(OutputFrag, storePos, vec4(0.0, 0.0, 0.0, 1.0)); // black
      }
      else if (min_importance == 1.0) {
          imageStore(OutputFrag, storePos, vec4(1.0, 1.0, 0.0, 1.0)); // yellow
      }
      else if (min_importance == 2.0) {
          imageStore(OutputFrag, storePos, vec4(0.0, 1.0, 0.0, 1.0)); // green
      }
      else if (min_importance == 3.0) {
          imageStore(OutputFrag, storePos, vec4(0.0, 0.0, 1.0, 1.0)); // blue
      }
      else {
          imageStore(OutputFrag, storePos, vec4(0.0, 1.0, 1.0, 1.0)); // cyan
      }


    }
  }
}