#version 430

layout(binding = 1) uniform sampler3D TexVolume;
layout(binding = 2) uniform sampler1D TexTransferFunc;
layout(binding = 3) uniform sampler3D TexVolumeGradient;

uniform vec3 VolumeGridResolution;
uniform vec3 VolumeVoxelSize;
uniform vec3 VolumeGridSize;

// I'm pretty sure I'm passing this right now.
// I'm using the same method as the volume texture.
layout (binding = 4) uniform sampler3D Importances;
uniform vec3 ImportancesGridSize; 

uniform vec3 CameraEye;

uniform mat4 u_CameraLookAt;
uniform mat4 ProjectionMatrix;

uniform float u_TanCameraFovY;
uniform float u_CameraAspectRatio;

uniform float StepSize;

uniform vec3 VolumeScales;

uniform int ApplyGradientPhongShading;

uniform float BlinnPhongKa;
uniform float BlinnPhongKd;
uniform float BlinnPhongKs;
uniform float BlinnPhongShininess;

uniform vec3 BlinnPhongIspecular;

uniform vec3 WorldEyePos;
uniform vec3 LightSourcePosition;

uniform int ApplyOcclusion;
uniform int ApplyShadow;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba16f, binding = 0) uniform image2D OutputFrag;

//////////////////////////////////////////////////////////////////////////////////////////////////
// From _structured_volume_data/ray_bbox_intersection.frag
struct Ray
{
    vec3 Origin;
    vec3 Dir;
};
bool RayAABBIntersection(vec3 vert_eye, vec3 vert_dir, vec3 vol_scaled_dim,
                         out Ray r, out float rtnear, out float rtfar);

// transfer function for importance - inlined
vec4 ImportanceTranferFunc(float importance)
{
    if (importance == 0.0) {
        return vec4(0.0, 0.0, 0.0, 1.0);
    }
    else if (importance == 1.0) {
        return vec4(1.0, 0.0, 0.0, 1.0);
    }
    else if (importance == 2.0) {
        return vec4(0.0, 1.0, 0.0, 1.0);
    }
    else if (importance == 3.0) {
        return vec4(0.0, 0.0, 1.0, 1.0);
    }
    else {
        return vec4(1.0, 1.0, 0.0, 0.0);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////////

void main()
{
    ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);

    ivec2 size = imageSize(OutputFrag);
    if (storePos.x < size.x && storePos.y < size.y)
    {
        // Get screen position [x, y] and consider centering the pixel by + 0.5
        vec2 fpos = vec2(storePos) + 0.5;

        // Transform fpos from [w, h] to [0, 1] to [-1, 1]
        vec3 VerPos = (vec3(fpos.x / float(size.x), fpos.y / float(size.y), 0.0) * 2.0) - 1.0;

        // Camera direction
        vec3 camera_dir = normalize(vec3(VerPos.x * u_TanCameraFovY * u_CameraAspectRatio, VerPos.y * u_TanCameraFovY, -1.0) * mat3(u_CameraLookAt));

        // Find Ray Intersection
        Ray r;
        float tnear, tfar;
        bool inbox = RayAABBIntersection(CameraEye, camera_dir, VolumeGridSize, r, tnear, tfar);

        // If inside volume grid
        if (inbox)
        {
            // Distance to be evaluated
            float D = abs(tfar - tnear);

            // Initialize Transparency and Radiance color
            vec4 dst = vec4(0.0);

            // World position at tnear, translated to the volume [0, VolumeGridSize]
            vec3 wld_pos = r.Origin + r.Dir * tnear;
            // Texture position
            vec3 tex_pos = wld_pos + (VolumeGridSize * 0.5);

            // Evaluate from 0 to D...
            for (float s = 0.0; s < D;)
            {
                // Get the current step or the remaining interval
                float h = min(StepSize, D - s);

                // Texture position at tnear + (s + h/2)
                vec3 s_tex_pos = tex_pos + r.Dir * (s + h * 0.5);

                // Get normalized density from volume
                float density = texture(TexVolume, s_tex_pos / VolumeGridSize).r;
                float importance = texture(Importances, s_tex_pos / ImportancesGridSize).r;

                // Get color from transfer function given the normalized density
                vec4 src =
                    // vec4(density)
                    texture(TexTransferFunc, density);

                vec4 src_importance = ImportanceTranferFunc(importance);

                // if sample is non-transparent
                if (src.a > 0.0)
                {
                    
                    ///// Evaluate the current opacity
                    ///src.a = 1.0 - exp(-src.a * h);

                    ///// Front-to-back composition
                    ///src.rgb = src.rgb * src.a;
                    ///dst = dst + (1.0 - dst.a) * src;

                    // Apply importance
                    dst = dst + (1.0 - dst.a) * src_importance;


                    // Opacity threshold: 99%
                    if (dst.a > 0.99)
                        break;
                }
                // Go to the next interval
                s = s + h;
            }
            imageStore(OutputFrag, storePos, dst);
        }
    }
}